#include "verify.h"
#include "../utils/util.h"

#include <solvers/smt2/smt2_dec.h>
#include <langapi/language_util.h>

#include <util/format_expr.h>
#include <util/replace_expr.h>
#include <util/replace_symbol.h>
#include <util/run.h>

#include "../utils/expr2sygus.h"
#include <iostream>

// prints solution
void display_solution(const solutiont &solution)
{
  std::cout<<"SOLUTION:"<<std::endl;
  for(const auto & f: solution.functions)
  {
    std::cout<<expr2sygus(f.first)<<"  =  "<<expr2sygus(f.second)<<std::endl;
  }
}

// prints counterexample
void display_cex(const counterexamplet &cex)
{
  std::cout<<"Counterexample:"<<std::endl;
  for(const auto & c: cex.assignment)
  {
    std::cout<<expr2sygus(c.first)<<"  =  "<<expr2sygus(c.second)<<std::endl;
  }
}

// adds the constraints to the solver
void verifyt::add_problem(const sygus_problemt &problem, const solutiont &solution, decision_proceduret &solver)
{   
 if(problem.assumptions.size() > 0)
    UNEXPECTEDCASE( "Assumptions are not supported in verify yet")
  // expand function applications, and add to solver.
  exprt constraints = conjunction(problem.constraints);
  expand_function_applications(constraints, solution.functions);
  expand_function_applications(constraints, problem.defined_functions);
  // expand again, incase the body of any defined functions contained the synth functions
  expand_function_applications(constraints, solution.functions);
  solver.set_to_false(constraints);
}

counterexamplet verifyt::get_counterexample(
  const decision_proceduret &solver, const sygus_problemt &problem) const
{
  counterexamplet result;

  // iterate over nondeterministic symbols, and get their value
  for(const auto &var : problem.free_var)
  {
    exprt value=solver.get(var);
    result.assignment[var]=value;
    if(value==nil_exprt() && var.id()==ID_nondet_symbol)
    {
      nondet_symbol_exprt tmp_var=to_nondet_symbol_expr(var);
      tmp_var.set_identifier("nondet_"+id2string(to_nondet_symbol_expr(var).get_identifier()));
      value=solver.get(tmp_var);
      result.assignment[var]=value;
    }
    if(value==nil_exprt())
    {
      result.assignment[var] = constant_exprt("0", var.type());
    }
  }

  return result;
}


verifyt::resultt verifyt::operator()(sygus_problemt &problem,
                                                         const solutiont &solution)
{
  // get SMT solver
  smt2_dect smtsolver(
      ns, "simple_verify", "generated by simple verify",
      "ALL", smt2_dect::solvert::Z3, log.get_message_handler());
  return this->operator()(problem, solution, smtsolver);
}

verifyt::resultt verifyt::operator()(sygus_problemt &problem,
    const solutiont &solution,
    decision_proceduret &solver)
  {
    add_problem(problem, solution, solver);
    decision_proceduret::resultt result = solver();

    switch(result)
    {
      case decision_proceduret::resultt::D_SATISFIABLE:
      {
        counterexample = get_counterexample(solver, problem);
        std::cout<<"Got a counterexample "<<std::endl;
        display_cex(counterexample);
        return verifyt::resultt::FAIL; 
      }
      case decision_proceduret::resultt::D_UNSATISFIABLE:
      {
        counterexample.clear();
        return verifyt::resultt::PASS;
      }

      case decision_proceduret::resultt::D_ERROR:
      default:
      {
        std::cout<<"ERROR in verification\n";
        return verifyt::resultt::FAIL;
      } 
    }
  }


counterexamplet verifyt::get_counterexample()
{
  return counterexample;
}  