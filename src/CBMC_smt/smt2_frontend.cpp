/*******************************************************************\

Module: SMT2 frontend example

Author: Elizabeth Polgreen, epolgreen@gmail.com

\*******************************************************************/

#include "parser.h"
#include "problem.h"

#include <fstream>
#include <iostream>

#include <util/cmdline.h>
#include <util/cout_message.h>
#include <util/format_expr.h>
#include <util/namespace.h>
#include <util/replace_symbol.h>
#include <util/simplify_expr.h>
#include <util/symbol_table.h>
#include <util/std_expr.h>
#include <util/expr.h>

#include <solvers/smt2/smt2_dec.h>

// I would do any preprocessing in this function
problemt build_problem(parsert &parser)
{
  problemt result;
  for (const auto &a : parser.assertions)
    result.assertions.push_back(a);

  // identify the free variables in the problem and add them to my model
  for (const auto &id : parser.id_map)
  {
    if (id.second.definition.is_nil() && id.second.kind == smt2_parsert::idt::VARIABLE)
      result.free_var[symbol_exprt(id.first, id.second.type)] = nil_exprt();
  }
  return result;
}

void print_problem_tree(problemt &problem, std::ostream &out)
{
  out << "Problem tree:" << std::endl;
  int count = 0;
  for (const auto &a : problem.assertions)
  {
    out << "Assertion " << count << std::endl;
    count++;
    out << a.pretty() << std::endl;
  }
}

// print the expression tree for each assertion
void print_problem(problemt &problem, std::ostream &out)
{
  out << "Problem:" << std::endl;
  int count = 0;
  for (const auto &a : problem.assertions)
  {
    out << "Assertion " << count << ": ";
    count++;
    out << format(a) << std::endl;
  }
}

void print_model(problemt &problem, std::ostream &out)
{
  out << "Model:" << std::endl;
  for (const auto &e : problem.free_var)
  {
    out << "Free var : " << e.first.get_identifier();
    if (!e.second.is_nil())
      out << " = " << format(e.second) << std::endl;
    else
      out << "[no assignment]" << std::endl;
  }
}

void traverse_expression(exprt &expr, std::ostream &out)
{
  Forall_operands(it, expr)
  {
    out << "looking at expression: " <<it->pretty() << std::endl;
    if (it->id() == ID_symbol)
    {
      out << "Found symbol: " << it->get(ID_identifier) << std::endl;
    }
    traverse_expression(*it, out);
  }

}

// send the problem to an SMT solver and get the result
decision_proceduret::resultt solve_problem(problemt &problem, namespacet &ns, messaget &log)
{
  log.status() << "Solving problem with smt2 solver" << messaget::eom;
  smt2_dect solver(
      ns, "fastsynth", "generated by fastsynth",
      "ALL", smt2_dect::solvert::Z3, log.get_message_handler());

  for (const auto &a : problem.assertions)
  {
    solver.set_to_true(a);
  }
  decision_proceduret::resultt result = solver();

  switch (result)
  {
  case decision_proceduret::resultt::D_SATISFIABLE:
  {
    log.status() << "RESULT is sat" << messaget::eom;
    for (const auto &e : problem.free_var)
    {
      exprt val = solver.get(e.first);
      problem.free_var[e.first] = val;
    }
    return result;
  }
  case decision_proceduret::resultt::D_UNSATISFIABLE:
  {
    log.status() << "RESULT is unsat" << messaget::eom;
    return result;
  }

  case decision_proceduret::resultt::D_ERROR:
  default:
  {
    log.status() << "ERROR from smt solver " << messaget::eom;
    return result;
  }
  }
  // UNREACHABLE
  return decision_proceduret::resultt::D_ERROR;
}

problemt substitute_model_into_problem(const problemt &problem)
{
  problemt new_problem;
  for (const auto &a : problem.assertions)
  {
    replace_symbolt replace_symbol;
    for (const auto &var : problem.free_var)
      replace_symbol.insert(var.first, var.second);

    exprt new_assertion = a;
    replace_symbol(new_assertion);
    new_problem.assertions.push_back(new_assertion);
  }
  return new_problem;
}

int smt2_frontend(const cmdlinet &cmdline)
{
  // parse input file
  assert(cmdline.args.size() == 1);
  std::ifstream in(cmdline.args.front());

  if (!in)
  {
    std::cerr << "Failed to open input file" << std::endl;
    return 10;
  }

  console_message_handlert message_handler;
  messaget message(message_handler);

  // this is our default verbosity
  unsigned int v = messaget::M_STATISTICS;

  if (cmdline.isset("verbosity"))
  {
    v = std::stol(
        cmdline.get_value("verbosity"));
    ;
    if (v > 10)
      v = 10;
  }

  symbol_tablet symbol_table;
  namespacet ns(symbol_table);

  message_handler.set_verbosity(v);
  parsert parser(in);
  // parse the problem
  try
  {
    parser.parse();
  }
  catch (const parsert::smt2_errort &e)
  {
    message.error() << e.get_line_no() << ": "
                    << e.what() << messaget::eom;
    return 20;
  }

  problemt problem = build_problem(parser);
  print_problem(problem, message.status());
  message.status() << messaget::eom;
  // solve the problem with an smt solver
  decision_proceduret::resultt res = solve_problem(problem, ns, message);
  // print problem and model
  print_model(problem, message.status());
  message.status() << messaget::eom;

  if (res == decision_proceduret::resultt::D_SATISFIABLE)
  {
    // replace the free variables in the assertions with the values from the model
    problemt new_problem = substitute_model_into_problem(problem);
    // print the new problem
    message.status() << "NEW PROBLEM" << messaget::eom;
    print_problem(new_problem, message.status());
    message.status() << messaget::eom;

    solve_problem(new_problem, ns, message);
  }

  message.status()<<"\n\nRunning traverse_expression"<<messaget::eom;
  traverse_expression(problem.assertions[0], message.status());
  message.status() << messaget::eom; // flush

  return 1;
}