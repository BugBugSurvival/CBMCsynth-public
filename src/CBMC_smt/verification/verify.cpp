#include "verify.h"

#include <solvers/smt2/smt2_dec.h>

#include <langapi/language_util.h>

#include <util/format_expr.h>
#include <util/replace_expr.h>
#include <util/replace_symbol.h>
#include <util/run.h>

#include "../utils/expr2sygus.h"
#include <iostream>

void display_solution(const solutiont &solution)
{
  std::cout<<"SOLUTION:"<<std::endl;
  for(const auto & f: solution.functions)
  {
    std::cout<<expr2sygus(f.first)<<"  =  "<<expr2sygus(f.second)<<std::endl;
  }
}

void display_cex(const counterexamplet &cex)
{
  std::cout<<"Counterexample:"<<std::endl;
  for(const auto & c: cex.assignment)
  {
    std::cout<<expr2sygus(c.first)<<"  =  "<<expr2sygus(c.second)<<std::endl;
  }
}

void verifyt::replace_synth_fun_parameters(const sygus_problemt &problem, std::map <symbol_exprt, exprt> &solution_functions)
{
  for(const auto &sf: problem.synthesis_functions)
  {
    const auto &args = sf.parameters;
    auto sol = solution_functions.find(symbol_exprt(sf.id, sf.type));
    if(sol==solution_functions.end())
      std::cout<<"warning, no solution for synth fun "<< id2string(sf.id)<<std::endl;

    const auto &domain = to_mathematical_function_type(sf.type).domain();
    for(std::size_t i=0; i< domain.size(); i++)
      replace_expr(symbol_exprt((args[i]), domain[i]), symbol_exprt("synth::parameter"+integer2string(i),domain[i]),sol->second);
  }
}

void verifyt::add_problem(const sygus_problemt &problem, const solutiont &solution, decision_proceduret &solver)
{
  // add verification problem "/exists x /neg (/alpha \implies \phi"
  verify_encoding.clear();
  verify_encodingt::check_function_bodies(solution.functions);
  verify_encoding.functions = solution.functions;
  replace_synth_fun_parameters(problem, verify_encoding.functions);
  
  verify_encoding.free_variables = problem.free_var;
  
  const exprt encoded_constraints = (problem.assumptions.size()>1)?
      verify_encoding(implies_exprt(conjunction(problem.assumptions),conjunction(problem.constraints))): 
      verify_encoding(conjunction(problem.constraints));

  solver.set_to_false(encoded_constraints);
}


verifyt::resultt verifyt::operator()(sygus_problemt &problem,
                                                         const solutiont &solution)
{
  // get SMT solver
  smt2_dect smtsolver(
      ns, "simple_verify", "generated by simple verify",
      "ALL", smt2_dect::solvert::Z3, log.get_message_handler());
  return this->operator()(problem, solution, smtsolver);
}

verifyt::resultt verifyt::operator()(sygus_problemt &problem,
    const solutiont &solution,
    decision_proceduret &solver)
  {
    add_problem(problem, solution, solver);
    decision_proceduret::resultt result = solver();

    switch(result)
    {
      case decision_proceduret::resultt::D_SATISFIABLE:
      {
        counterexample = verify_encoding.get_counterexample(solver);
        std::cout<<"Got a counterexample "<<std::endl;
        display_cex(counterexample);
        return verifyt::resultt::FAIL; 
      }
      case decision_proceduret::resultt::D_UNSATISFIABLE:
      {
        counterexample.clear();
        // std::cout<<"No counterexample "<<std::endl;
        return verifyt::resultt::PASS;
      }

      case decision_proceduret::resultt::D_ERROR:
      default:
      {
        std::cout<<"ERROR in verification\n";
        counterexample=
        verify_encoding.get_counterexample(solver);
        return verifyt::resultt::FAIL;
      } 
    }
  }


counterexamplet verifyt::get_counterexample()
{
  return counterexample;
}  